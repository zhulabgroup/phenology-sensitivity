---
title: 'explore PMM'
embed-resources: true
author: "Yi Liu"
date: "`r format(Sys.Date(), '%m/%d/%Y')`"
format:
  html:
    code-folding: show
    highlight: textmate
    number-sections: true
    theme: flatly
    toc: TRUE
    toc-depth: 4
    toc-float:
      collapsed: false
      smooth-scroll: true
---

```{r setup, include=FALSE}
library(dplyr)
library(ggplot2)
library(patchwork)
library(ggtext)


```

# check the evolution distance
```{r}
library(ape)

tree <- read.tree("../data/phylogenetics/timetree.nwk") %>% 
  # replace "_" with " " in tip labels
  {
    new_tree <- .
    new_tree$tip.label <- gsub("_", " ", new_tree$tip.label)
    new_tree$tip.label <- gsub("Morus celtidifolia", "Morus microphylla", new_tree$tip.label)
    new_tree
  }
```

```{r}
distances <- cophenetic.phylo(tree)
```

```{r}
temperature_data <- read.csv("../data/herb_temperature_data.csv")

temperature_data_model <- temperature_data %>%
  group_by(species) %>%
  # filter(n_distinct(doy) > 10) %>%  # hard to justify
  filter(n_distinct(anom) > 10) %>%  # Use n_distinct() for distinct counting
  filter(n_distinct(norm) > 10) %>%  # Use n_distinct() for distinct counting
  filter(n_distinct(doy, norm, anom) > 30) %>%  # Use n_distinct() for distinct counting
  ungroup() 

```


let's try whether not matching the species work

```{r}
pheno_species <- temperature_data_model %>%
  distinct(species)

phylo_species <- tree$tip.label 
# %>% 
# # replace Morus microphylla with Morus microphylla var. microphylla
#   gsub("Morus celtidifolia", "Morus microphylla", .) 

setdiff(pheno_species$species, phylo_species) # check the one name to correct
```

```{r}
phylo_species_df <- data.frame(species = phylo_species)

phylo_species_id <- phylo_species_df %>% 
  mutate(sppid = 1:n())

temperature_data_model_phylo <- temperature_data_model %>%
  filter(species %in% phylo_species_df$species) %>% 
  dplyr::select(species, doy, norm, anom, yeart) %>% 
  left_join(phylo_species_id, by = "species")
# %>% # filter out the species not in the phylo tree
#   distinct(species) # check the species

nspecies <- n_distinct(temperature_data_model_phylo$species)
```



```{r}
library(rstan)
options(mc.cores = parallel::detectCores())

  fitlambest <- stan("../data/phylogenetics/PhenoPhyloMM_PMM_Yi.stan",
              data=list(N=nrow(temperature_data_model_phylo),
                        n_sp=nspecies,
                        sp=temperature_data_model_phylo$sppid,
                        x1=temperature_data_model_phylo$yeart,
                        x2=temperature_data_model_phylo$anom,
                        y=temperature_data_model_phylo$doy,
                        Vphy=vcv(tree, corr = TRUE)), # vcv: Phylogenetic Variance-covariance or Correlation Matrix

              iter = 10000, #4000
              warmup = 2000, # half the iter as warmp is default, but leaving in case we want to change
              chains = 4, #4
              seed = 2 
  )
  
  ## Save fitted posterior
  saveRDS(fitlambest, "../data/phylogenetics/fit_model_PMM_more.rds")
  

```


```{r}
fitlambest <- readRDS("../data/phylogenetics/fit_model_PMM_newprior_more.rds")
# summarize the results
fitsum <- summary(fitlambest, pars = c("a_z", "sigma_interceptsa", 
                                       "b_zf", "sigma_interceptsbf", "lam_interceptsbf", 
                                       "b_zc", "sigma_interceptsbc", "lam_interceptsbc"))
fitsumdf <- as.data.frame(fitsum)



```

```{r}
# Extract summary of b_zc
b_zc_samples <- extract(fitlambest)$b_zc

# Calculate the 95% confidence interval
ci_lower <- quantile(b_zc_samples, 0.025)
ci_upper <- quantile(b_zc_samples, 0.975)

# Create a data frame for plotting
b_zc_df <- data.frame(b_zc = b_zc_samples)

# Plot the distribution using ggplot2
ggplot(b_zc_df, aes(x = b_zc)) +
  geom_density(fill = "blue", alpha = 0.5) +  # Plot the density
  geom_vline(xintercept = ci_lower, color = "red", linetype = "dashed") +  # Lower 95% CI line
  geom_vline(xintercept = ci_upper, color = "red", linetype = "dashed") +  # Upper 95% CI line
  labs(title = "Distribution of diff with 95% Confidence Interval",
       x = "b_zc",
       y = "Density") +
  theme_minimal()
```
```{r}
# Extract summary of b_zc
b_zc_samples <- extract(fitlambest)$lam_interceptsbc

# Calculate the 95% confidence interval
ci_lower <- quantile(b_zc_samples, 0.025)
ci_upper <- quantile(b_zc_samples, 0.975)

# Create a data frame for plotting
b_zc_df <- data.frame(b_zc = b_zc_samples)

# Plot the distribution using ggplot2
ggplot(b_zc_df, aes(x = b_zc)) +
  geom_density(fill = "blue", alpha = 0.5) +  # Plot the density
  geom_vline(xintercept = ci_lower, color = "red", linetype = "dashed") +  # Lower 95% CI line
  geom_vline(xintercept = ci_upper, color = "red", linetype = "dashed") +  # Upper 95% CI line
  labs(title = "Distribution of diff_lam with 95% Confidence Interval",
       x = "b_zc",
       y = "Density") +
  theme_minimal()
```
```{r}
# Extract summary of b_zc
b_zc_samples <- extract(fitlambest)$lam_interceptsbf

# Calculate the 95% confidence interval
ci_lower <- quantile(b_zc_samples, 0.025)
ci_upper <- quantile(b_zc_samples, 0.975)

# Create a data frame for plotting
b_zc_df <- data.frame(b_zc = b_zc_samples)

# Plot the distribution using ggplot2
ggplot(b_zc_df, aes(x = b_zc)) +
  geom_density(fill = "blue", alpha = 0.5) +  # Plot the density
  geom_vline(xintercept = ci_lower, color = "red", linetype = "dashed") +  # Lower 95% CI line
  geom_vline(xintercept = ci_upper, color = "red", linetype = "dashed") +  # Upper 95% CI line
  labs(title = "Distribution of spatial sensitivity_lam with 95% Confidence Interval",
       x = "b_zc",
       y = "Density") +
  theme_minimal()
```

```{r}
# Extract summary of b_zc
b_zc_samples <- extract(fitlambest)$sigma_interceptsbc


# Calculate the 95% confidence interval
ci_lower <- quantile(b_zc_samples, 0.025)
ci_upper <- quantile(b_zc_samples, 0.975)

# Create a data frame for plotting
b_zc_df <- data.frame(b_zc = b_zc_samples)

# Plot the distribution using ggplot2
ggplot(b_zc_df, aes(x = b_zc)) +
  geom_density(fill = "blue", alpha = 0.5) +  # Plot the density
  geom_vline(xintercept = ci_lower, color = "red", linetype = "dashed") +  # Lower 95% CI line
  geom_vline(xintercept = ci_upper, color = "red", linetype = "dashed") +  # Upper 95% CI line
  labs(title = "Distribution of diff_sigma with 95% Confidence Interval",
       x = "b_zc",
       y = "Density") +
  theme_minimal()
```


# try HMM to see why it's different from BLME
```{r}
  fitlamb0 <- stan("../data/phylogenetics/PhenoPhyloMM_HMM_Yi.stan",
                   data=list(N=nrow(temperature_data_model_phylo),
                        n_sp=nspecies,
                        sp=temperature_data_model_phylo$sppid,
                        x1=temperature_data_model_phylo$yeart,
                        x2=temperature_data_model_phylo$anom,
                        y=temperature_data_model_phylo$doy,
                        Vphy=vcv(tree, corr = TRUE)),
              iter = 10000, #4000
              warmup = 2000, # half the iter as warmp is default, but leaving in case we want to change
              chains = 4, #4
              seed = 2  
  )
  saveRDS(fitlamb0, "../data/phylogenetics/fit_model_HMM.rds")
```

# using BLME for HMM
```{r}
library(blme)
temporal_model <- blmer(doy ~ yeart + anom + (1 + yeart + anom | species), 
                        data = temperature_data_model_phylo,
                        cov.prior = invwishart(df = 3, scale = diag(c(50, 50, 50), 3)))

summary(temporal_model)
```





# download and merge my own tree
```{r}

tree_most <- read.tree("../data/phylogenetics/timetree.nwk")
plot(tree_most)
```

```{r}
tree_few <- read.tree("../data/phylogenetics/phyloT_generated_tree_1727817578_newick.txt")
plot(tree_few) # looks like it doesn't make since to marge the trees
```

```{r}
```


# check multivariate normal distribution
```{r}
# Load necessary library
library(mvtnorm)

# Define mean vector and covariance matrix for the bivariate normal distribution
mu <- c(0, 0)
sigma <- matrix(c(1, 0, 0, 3), 2, 2)

# Generate a grid of points
x <- seq(-3, 3, length = 50)
y <- seq(-3, 3, length = 50)
xy <- expand.grid(x = x, y = y)

# Compute the bivariate normal density values
z <- matrix(dmvnorm(xy, mean = mu, sigma = sigma), nrow = length(x))

# Plot using filled.contour to represent the third dimension as color
filled.contour(x, y, z, color.palette = terrain.colors, 
               xlab = "X", ylab = "Y", main = "Bivariate Normal Distribution", asp = 1)
```

